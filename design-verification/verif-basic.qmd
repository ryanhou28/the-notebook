# Verification Basics

Verification: testing and validating the correctness and functionality of a design

**Code coverage** tells us how much of the code in the DUT has been executed by the testbench, while **functional coverage** tells us how well the functionality of the DUT has been tested by the testbench.

- **functional coverage** measures how well the verification environment exercises the intended functionality of the design. It checks whether all important scenarios, features, and corner cases are tested. Functional coverage is user-defined
- **Code coverage** measures how much of the RTL code has been exercised by the testbench. It is automatically generated by EDA tools
  - Statement Coverage: Checks if every executable statement in the RTL has been executed.
  - Branch Coverage: Ensures all branches of an if or case statement are exercised.
  - Expression Coverage: Evaluates whether all boolean expressions have been evaluated to both true and false.
  - FSM (Finite State Machine) Coverage: Ensures that all states and transitions in an FSM are exercised.
  - Toggle Coverage: Monitors if all bits of a register or signal toggle from 0→1 and 1→0.
- **Assertion Coverage** measures whether all formal properties and assertions written in SystemVerilog Assertions (SVA) have been exercised during simulation

When can you stop verification?

- No fixed rule! Common criterias:
- Achieving code coverage goals
- Achieving functional coverage goals
- Meeting performance goals
  - timing constraints, power, area, etc
- Finding and fixing all critical bugs
- Available resources

## ASIC Design Flow

1. Requirements
2. Specifications
3. Architecture
4. Digital Design
5. Verification
6. Logic Synthesis
7. Logic Equivalence
8. Placement & Routing
9. Validation

- Note that above steps a huge simplification and are often intertwined and fed back, as multiple iterations of the steps are gone through

## Verification Techniques


- Functional Simulation: running design in simulation to validate its functionality, using various inputs, such as test vectors
- Formal verification: use mathematical proofs to verify the correctness of the design, often used for critical designs (eg safety-critical systems)
- Emulation: testing on specialized hardware that can emulate the behavior of the system, often for large, complex designs that can't be simulated on a computer
- Prototyping: building a physical prototype of the system to test its functionality in a real-world environment (often used for designs that require testing with real-world inputs and conditions)

## Verification Stages

- Planning
- Testbench development
  - Develop testbench environment, provide inputs
- Test creation
  - Create tests based on spec
- Test execution
- Coverage analysis
- Debugging
- Closure

### Levels of Verification

- **Unit Level**
  - lowest level, verify individual modules/blocks
- **Block Level**
  - Multiple modules/blocks are integrated and verified together
- **Subsystem Level**
- **Chip level / SOC level**

## Directed Verification

- A type of functional verification where tests are created to test specific features/functions
- Done with different types of testbenches:
  - file-based
  - linear
  - state machine-based

Limitations:

- Limited test coverage
- Bias towards designer's assumptions
- Difficult to detect complex bugs
- Limited scalability
- Time-consuming to create

## Constraint Random Verification

generating randomized test cases with specific constraints to ensure that the generated input stimuli meet certain design requirements.

limitations: The generated test cases may not cover all possible scenarios

## Assertion Based Verification

assertions are used as the primary means of verifying the correctness of a digital design. Assertions are statements that describe a condition that must always be true within a design

basic idea: to use a combination of functional and formal verification techniques to verify the design

SystemVerilog Assertions. Example:

```
assert property ( @(posedge clk) disable iff (!rst_n)
    (in_fifo_wr && !in_fifo_full) ##[1:$] !in_fifo_empty && !in_fifo_wr );
```



## Verification Plan

Contents of a verification plan:

- Overview
- Scope and Goal
- Methodology
- Testbench Architecture
- Test Cases
- Coverage Metrics
  - A description of the coverage metrics to be used, including functional coverage, code coverage, and assertion coverage
- Sign-off Criteria



### Example Verification Plan

- Introduction
  - Description of the design and its purpose
  - Goals of the verification process
- Verification Environment
  - Description of the simulation environment
  - List of all verification components
  - Details of the simulation flow
- Features to be Verified
  - List of all design features to be verified
  - Description of the expected behavior of each feature
- Test Plan
  - List of all test cases
  - Description of the purpose and scope of each test case
  - Expected results for each test case
  - Pass/fail criteria for each test case
- Code/Functional/Assertion Coverage Plan
  - Description of the code coverage metrics to be used
  - Goal for each coverage metric
  - Methodology for measuring code coverage
- Bug Tracking
  - Methodology for tracking and reporting bugs
  - Reporting format for each bug
  - Bug severity levels and priority
- Sign-off Criteria
  - Criteria for determining when verification is complete
  - Criteria for determining if the design is ready for tapeout
  - Verification closure process

